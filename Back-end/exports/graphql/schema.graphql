input FileInfoInput {
  name: String
  alternativeText: String
  caption: String
}

type UsersPermissionsMe {
  id: ID!
  username: String!
  email: String!
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsMeRole
}

type UsersPermissionsMeRole {
  id: ID!
  name: String!
  description: String
  type: String
}

input UsersPermissionsRegisterInput {
  username: String!
  email: String!
  password: String!
}

input UsersPermissionsLoginInput {
  identifier: String!
  password: String!
  provider: String = "local"
}

type UsersPermissionsLoginPayload {
  jwt: String
  user: UsersPermissionsMe!
}

type UserPermissionsPasswordPayload {
  ok: Boolean!
}

type Blog {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  title: String
  author: String
  content: String
  date: String
  image: UploadFile
  slug: String
  categorie: String
  blogcategory: Blogcategory
  description: String
  published_at: DateTime
}

type BlogConnection {
  values: [Blog]
  groupBy: BlogGroupBy
  aggregate: BlogAggregator
}

type BlogAggregator {
  count: Int
  totalCount: Int
}

type BlogGroupBy {
  id: [BlogConnectionId]
  created_at: [BlogConnectionCreated_at]
  updated_at: [BlogConnectionUpdated_at]
  title: [BlogConnectionTitle]
  author: [BlogConnectionAuthor]
  content: [BlogConnectionContent]
  date: [BlogConnectionDate]
  image: [BlogConnectionImage]
  slug: [BlogConnectionSlug]
  categorie: [BlogConnectionCategorie]
  blogcategory: [BlogConnectionBlogcategory]
  description: [BlogConnectionDescription]
  published_at: [BlogConnectionPublished_at]
}

type BlogConnectionId {
  key: ID
  connection: BlogConnection
}

type BlogConnectionCreated_at {
  key: DateTime
  connection: BlogConnection
}

type BlogConnectionUpdated_at {
  key: DateTime
  connection: BlogConnection
}

type BlogConnectionTitle {
  key: String
  connection: BlogConnection
}

type BlogConnectionAuthor {
  key: String
  connection: BlogConnection
}

type BlogConnectionContent {
  key: String
  connection: BlogConnection
}

type BlogConnectionDate {
  key: String
  connection: BlogConnection
}

type BlogConnectionImage {
  key: ID
  connection: BlogConnection
}

type BlogConnectionSlug {
  key: String
  connection: BlogConnection
}

type BlogConnectionCategorie {
  key: String
  connection: BlogConnection
}

type BlogConnectionBlogcategory {
  key: ID
  connection: BlogConnection
}

type BlogConnectionDescription {
  key: String
  connection: BlogConnection
}

type BlogConnectionPublished_at {
  key: DateTime
  connection: BlogConnection
}

input BlogInput {
  title: String
  author: String
  content: String
  date: String
  image: ID
  slug: String
  categorie: String
  blogcategory: ID
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editBlogInput {
  title: String
  author: String
  content: String
  date: String
  image: ID
  slug: String
  categorie: String
  blogcategory: ID
  description: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createBlogInput {
  data: BlogInput
}

type createBlogPayload {
  blog: Blog
}

input updateBlogInput {
  where: InputID
  data: editBlogInput
}

type updateBlogPayload {
  blog: Blog
}

input deleteBlogInput {
  where: InputID
}

type deleteBlogPayload {
  blog: Blog
}

type Blogcategory {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  slug: String
  published_at: DateTime
  blogs(sort: String, limit: Int, start: Int, where: JSON): [Blog]
}

type BlogcategoryConnection {
  values: [Blogcategory]
  groupBy: BlogcategoryGroupBy
  aggregate: BlogcategoryAggregator
}

type BlogcategoryAggregator {
  count: Int
  totalCount: Int
}

type BlogcategoryGroupBy {
  id: [BlogcategoryConnectionId]
  created_at: [BlogcategoryConnectionCreated_at]
  updated_at: [BlogcategoryConnectionUpdated_at]
  name: [BlogcategoryConnectionName]
  slug: [BlogcategoryConnectionSlug]
  published_at: [BlogcategoryConnectionPublished_at]
}

type BlogcategoryConnectionId {
  key: ID
  connection: BlogcategoryConnection
}

type BlogcategoryConnectionCreated_at {
  key: DateTime
  connection: BlogcategoryConnection
}

type BlogcategoryConnectionUpdated_at {
  key: DateTime
  connection: BlogcategoryConnection
}

type BlogcategoryConnectionName {
  key: String
  connection: BlogcategoryConnection
}

type BlogcategoryConnectionSlug {
  key: String
  connection: BlogcategoryConnection
}

type BlogcategoryConnectionPublished_at {
  key: DateTime
  connection: BlogcategoryConnection
}

input BlogcategoryInput {
  name: String
  slug: String
  blogs: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editBlogcategoryInput {
  name: String
  slug: String
  blogs: [ID]
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createBlogcategoryInput {
  data: BlogcategoryInput
}

type createBlogcategoryPayload {
  blogcategory: Blogcategory
}

input updateBlogcategoryInput {
  where: InputID
  data: editBlogcategoryInput
}

type updateBlogcategoryPayload {
  blogcategory: Blogcategory
}

input deleteBlogcategoryInput {
  where: InputID
}

type deleteBlogcategoryPayload {
  blogcategory: Blogcategory
}

type Producteur {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  client: String
  lieu: String
  content: String
  published_at: DateTime
  image_profil(sort: String, limit: Int, start: Int, where: JSON): [UploadFile]
}

type ProducteurConnection {
  values: [Producteur]
  groupBy: ProducteurGroupBy
  aggregate: ProducteurAggregator
}

type ProducteurAggregator {
  count: Int
  totalCount: Int
}

type ProducteurGroupBy {
  id: [ProducteurConnectionId]
  created_at: [ProducteurConnectionCreated_at]
  updated_at: [ProducteurConnectionUpdated_at]
  name: [ProducteurConnectionName]
  client: [ProducteurConnectionClient]
  lieu: [ProducteurConnectionLieu]
  content: [ProducteurConnectionContent]
  published_at: [ProducteurConnectionPublished_at]
}

type ProducteurConnectionId {
  key: ID
  connection: ProducteurConnection
}

type ProducteurConnectionCreated_at {
  key: DateTime
  connection: ProducteurConnection
}

type ProducteurConnectionUpdated_at {
  key: DateTime
  connection: ProducteurConnection
}

type ProducteurConnectionName {
  key: String
  connection: ProducteurConnection
}

type ProducteurConnectionClient {
  key: String
  connection: ProducteurConnection
}

type ProducteurConnectionLieu {
  key: String
  connection: ProducteurConnection
}

type ProducteurConnectionContent {
  key: String
  connection: ProducteurConnection
}

type ProducteurConnectionPublished_at {
  key: DateTime
  connection: ProducteurConnection
}

input ProducteurInput {
  name: String
  client: String
  lieu: String
  image_profil: [ID]
  content: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProducteurInput {
  name: String
  client: String
  lieu: String
  image_profil: [ID]
  content: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProducteurInput {
  data: ProducteurInput
}

type createProducteurPayload {
  producteur: Producteur
}

input updateProducteurInput {
  where: InputID
  data: editProducteurInput
}

type updateProducteurPayload {
  producteur: Producteur
}

input deleteProducteurInput {
  where: InputID
}

type deleteProducteurPayload {
  producteur: Producteur
}

type ProductsCategorie {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  slug: String
  published_at: DateTime
  produits(sort: String, limit: Int, start: Int, where: JSON): [Produit]
}

type ProductsCategorieConnection {
  values: [ProductsCategorie]
  groupBy: ProductsCategorieGroupBy
  aggregate: ProductsCategorieAggregator
}

type ProductsCategorieAggregator {
  count: Int
  totalCount: Int
}

type ProductsCategorieGroupBy {
  id: [ProductsCategorieConnectionId]
  created_at: [ProductsCategorieConnectionCreated_at]
  updated_at: [ProductsCategorieConnectionUpdated_at]
  name: [ProductsCategorieConnectionName]
  slug: [ProductsCategorieConnectionSlug]
  published_at: [ProductsCategorieConnectionPublished_at]
}

type ProductsCategorieConnectionId {
  key: ID
  connection: ProductsCategorieConnection
}

type ProductsCategorieConnectionCreated_at {
  key: DateTime
  connection: ProductsCategorieConnection
}

type ProductsCategorieConnectionUpdated_at {
  key: DateTime
  connection: ProductsCategorieConnection
}

type ProductsCategorieConnectionName {
  key: String
  connection: ProductsCategorieConnection
}

type ProductsCategorieConnectionSlug {
  key: String
  connection: ProductsCategorieConnection
}

type ProductsCategorieConnectionPublished_at {
  key: DateTime
  connection: ProductsCategorieConnection
}

input ProductsCategorieInput {
  name: String
  produits: [ID]
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProductsCategorieInput {
  name: String
  produits: [ID]
  slug: String
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProductsCategorieInput {
  data: ProductsCategorieInput
}

type createProductsCategoriePayload {
  productsCategorie: ProductsCategorie
}

input updateProductsCategorieInput {
  where: InputID
  data: editProductsCategorieInput
}

type updateProductsCategoriePayload {
  productsCategorie: ProductsCategorie
}

input deleteProductsCategorieInput {
  where: InputID
}

type deleteProductsCategoriePayload {
  productsCategorie: ProductsCategorie
}

type Produit {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  poids: String
  prix: Float
  producteurs: String
  quantite: Int
  stocks: Int
  image: UploadFile
  products_categorie: ProductsCategorie
  published_at: DateTime
}

type ProduitConnection {
  values: [Produit]
  groupBy: ProduitGroupBy
  aggregate: ProduitAggregator
}

type ProduitAggregator {
  count: Int
  totalCount: Int
  sum: ProduitAggregatorSum
  avg: ProduitAggregatorAvg
  min: ProduitAggregatorMin
  max: ProduitAggregatorMax
}

type ProduitAggregatorSum {
  prix: Float
  quantite: Float
  stocks: Float
}

type ProduitAggregatorAvg {
  prix: Float
  quantite: Float
  stocks: Float
}

type ProduitAggregatorMin {
  prix: Float
  quantite: Float
  stocks: Float
}

type ProduitAggregatorMax {
  prix: Float
  quantite: Float
  stocks: Float
}

type ProduitGroupBy {
  id: [ProduitConnectionId]
  created_at: [ProduitConnectionCreated_at]
  updated_at: [ProduitConnectionUpdated_at]
  name: [ProduitConnectionName]
  poids: [ProduitConnectionPoids]
  prix: [ProduitConnectionPrix]
  producteurs: [ProduitConnectionProducteurs]
  quantite: [ProduitConnectionQuantite]
  stocks: [ProduitConnectionStocks]
  image: [ProduitConnectionImage]
  products_categorie: [ProduitConnectionProducts_categorie]
  published_at: [ProduitConnectionPublished_at]
}

type ProduitConnectionId {
  key: ID
  connection: ProduitConnection
}

type ProduitConnectionCreated_at {
  key: DateTime
  connection: ProduitConnection
}

type ProduitConnectionUpdated_at {
  key: DateTime
  connection: ProduitConnection
}

type ProduitConnectionName {
  key: String
  connection: ProduitConnection
}

type ProduitConnectionPoids {
  key: String
  connection: ProduitConnection
}

type ProduitConnectionPrix {
  key: Float
  connection: ProduitConnection
}

type ProduitConnectionProducteurs {
  key: String
  connection: ProduitConnection
}

type ProduitConnectionQuantite {
  key: Int
  connection: ProduitConnection
}

type ProduitConnectionStocks {
  key: Int
  connection: ProduitConnection
}

type ProduitConnectionImage {
  key: ID
  connection: ProduitConnection
}

type ProduitConnectionProducts_categorie {
  key: ID
  connection: ProduitConnection
}

type ProduitConnectionPublished_at {
  key: DateTime
  connection: ProduitConnection
}

input ProduitInput {
  name: String
  poids: String
  prix: Float
  producteurs: String
  quantite: Int
  stocks: Int
  image: ID
  products_categorie: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input editProduitInput {
  name: String
  poids: String
  prix: Float
  producteurs: String
  quantite: Int
  stocks: Int
  image: ID
  products_categorie: ID
  published_at: DateTime
  created_by: ID
  updated_by: ID
}

input createProduitInput {
  data: ProduitInput
}

type createProduitPayload {
  produit: Produit
}

input updateProduitInput {
  where: InputID
  data: editProduitInput
}

type updateProduitPayload {
  produit: Produit
}

input deleteProduitInput {
  where: InputID
}

type deleteProduitPayload {
  produit: Produit
}

type I18NLocale {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String
  code: String
}

input LocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

input editLocaleInput {
  name: String
  code: String
  created_by: ID
  updated_by: ID
}

type UploadFile {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related(sort: String, limit: Int, start: Int, where: JSON): [Morph]
}

type UploadFileConnection {
  values: [UploadFile]
  groupBy: UploadFileGroupBy
  aggregate: UploadFileAggregator
}

type UploadFileAggregator {
  count: Int
  totalCount: Int
  sum: UploadFileAggregatorSum
  avg: UploadFileAggregatorAvg
  min: UploadFileAggregatorMin
  max: UploadFileAggregatorMax
}

type UploadFileAggregatorSum {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorAvg {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMin {
  width: Float
  height: Float
  size: Float
}

type UploadFileAggregatorMax {
  width: Float
  height: Float
  size: Float
}

type UploadFileGroupBy {
  id: [UploadFileConnectionId]
  created_at: [UploadFileConnectionCreated_at]
  updated_at: [UploadFileConnectionUpdated_at]
  name: [UploadFileConnectionName]
  alternativeText: [UploadFileConnectionAlternativeText]
  caption: [UploadFileConnectionCaption]
  width: [UploadFileConnectionWidth]
  height: [UploadFileConnectionHeight]
  formats: [UploadFileConnectionFormats]
  hash: [UploadFileConnectionHash]
  ext: [UploadFileConnectionExt]
  mime: [UploadFileConnectionMime]
  size: [UploadFileConnectionSize]
  url: [UploadFileConnectionUrl]
  previewUrl: [UploadFileConnectionPreviewUrl]
  provider: [UploadFileConnectionProvider]
  provider_metadata: [UploadFileConnectionProvider_metadata]
}

type UploadFileConnectionId {
  key: ID
  connection: UploadFileConnection
}

type UploadFileConnectionCreated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionUpdated_at {
  key: DateTime
  connection: UploadFileConnection
}

type UploadFileConnectionName {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionAlternativeText {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionCaption {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionWidth {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionHeight {
  key: Int
  connection: UploadFileConnection
}

type UploadFileConnectionFormats {
  key: JSON
  connection: UploadFileConnection
}

type UploadFileConnectionHash {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionExt {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionMime {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionSize {
  key: Float
  connection: UploadFileConnection
}

type UploadFileConnectionUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionPreviewUrl {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider {
  key: String
  connection: UploadFileConnection
}

type UploadFileConnectionProvider_metadata {
  key: JSON
  connection: UploadFileConnection
}

input FileInput {
  name: String!
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String!
  ext: String
  mime: String!
  size: Float!
  url: String!
  previewUrl: String
  provider: String!
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input editFileInput {
  name: String
  alternativeText: String
  caption: String
  width: Int
  height: Int
  formats: JSON
  hash: String
  ext: String
  mime: String
  size: Float
  url: String
  previewUrl: String
  provider: String
  provider_metadata: JSON
  related: [ID]
  created_by: ID
  updated_by: ID
}

input deleteFileInput {
  where: InputID
}

type deleteFilePayload {
  file: UploadFile
}

type UsersPermissionsPermission {
  id: ID!
  type: String!
  controller: String!
  action: String!
  enabled: Boolean!
  policy: String
  role: UsersPermissionsRole
}

type UsersPermissionsRole {
  id: ID!
  name: String!
  description: String
  type: String
  permissions(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsPermission]
  users(sort: String, limit: Int, start: Int, where: JSON): [UsersPermissionsUser]
}

type UsersPermissionsRoleConnection {
  values: [UsersPermissionsRole]
  groupBy: UsersPermissionsRoleGroupBy
  aggregate: UsersPermissionsRoleAggregator
}

type UsersPermissionsRoleAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsRoleGroupBy {
  id: [UsersPermissionsRoleConnectionId]
  name: [UsersPermissionsRoleConnectionName]
  description: [UsersPermissionsRoleConnectionDescription]
  type: [UsersPermissionsRoleConnectionType]
}

type UsersPermissionsRoleConnectionId {
  key: ID
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionName {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionDescription {
  key: String
  connection: UsersPermissionsRoleConnection
}

type UsersPermissionsRoleConnectionType {
  key: String
  connection: UsersPermissionsRoleConnection
}

input RoleInput {
  name: String!
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input editRoleInput {
  name: String
  description: String
  type: String
  permissions: [ID]
  users: [ID]
  created_by: ID
  updated_by: ID
}

input createRoleInput {
  data: RoleInput
}

type createRolePayload {
  role: UsersPermissionsRole
}

input updateRoleInput {
  where: InputID
  data: editRoleInput
}

type updateRolePayload {
  role: UsersPermissionsRole
}

input deleteRoleInput {
  where: InputID
}

type deleteRolePayload {
  role: UsersPermissionsRole
}

type UsersPermissionsUser {
  id: ID!
  created_at: DateTime!
  updated_at: DateTime!
  username: String!
  email: String!
  provider: String
  confirmed: Boolean
  blocked: Boolean
  role: UsersPermissionsRole
}

type UsersPermissionsUserConnection {
  values: [UsersPermissionsUser]
  groupBy: UsersPermissionsUserGroupBy
  aggregate: UsersPermissionsUserAggregator
}

type UsersPermissionsUserAggregator {
  count: Int
  totalCount: Int
}

type UsersPermissionsUserGroupBy {
  id: [UsersPermissionsUserConnectionId]
  created_at: [UsersPermissionsUserConnectionCreated_at]
  updated_at: [UsersPermissionsUserConnectionUpdated_at]
  username: [UsersPermissionsUserConnectionUsername]
  email: [UsersPermissionsUserConnectionEmail]
  provider: [UsersPermissionsUserConnectionProvider]
  confirmed: [UsersPermissionsUserConnectionConfirmed]
  blocked: [UsersPermissionsUserConnectionBlocked]
  role: [UsersPermissionsUserConnectionRole]
}

type UsersPermissionsUserConnectionId {
  key: ID
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionCreated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUpdated_at {
  key: DateTime
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionUsername {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionEmail {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionProvider {
  key: String
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionConfirmed {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionBlocked {
  key: Boolean
  connection: UsersPermissionsUserConnection
}

type UsersPermissionsUserConnectionRole {
  key: ID
  connection: UsersPermissionsUserConnection
}

input UserInput {
  username: String!
  email: String!
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input editUserInput {
  username: String
  email: String
  provider: String
  password: String
  resetPasswordToken: String
  confirmationToken: String
  confirmed: Boolean
  blocked: Boolean
  role: ID
  created_by: ID
  updated_by: ID
}

input createUserInput {
  data: UserInput
}

type createUserPayload {
  user: UsersPermissionsUser
}

input updateUserInput {
  where: InputID
  data: editUserInput
}

type updateUserPayload {
  user: UsersPermissionsUser
}

input deleteUserInput {
  where: InputID
}

type deleteUserPayload {
  user: UsersPermissionsUser
}

union Morph = UsersPermissionsMe | UsersPermissionsMeRole | UsersPermissionsLoginPayload | UserPermissionsPasswordPayload | Blog | BlogConnection | BlogAggregator | BlogGroupBy | BlogConnectionId | BlogConnectionCreated_at | BlogConnectionUpdated_at | BlogConnectionTitle | BlogConnectionAuthor | BlogConnectionContent | BlogConnectionDate | BlogConnectionImage | BlogConnectionSlug | BlogConnectionCategorie | BlogConnectionBlogcategory | BlogConnectionDescription | BlogConnectionPublished_at | createBlogPayload | updateBlogPayload | deleteBlogPayload | Blogcategory | BlogcategoryConnection | BlogcategoryAggregator | BlogcategoryGroupBy | BlogcategoryConnectionId | BlogcategoryConnectionCreated_at | BlogcategoryConnectionUpdated_at | BlogcategoryConnectionName | BlogcategoryConnectionSlug | BlogcategoryConnectionPublished_at | createBlogcategoryPayload | updateBlogcategoryPayload | deleteBlogcategoryPayload | Producteur | ProducteurConnection | ProducteurAggregator | ProducteurGroupBy | ProducteurConnectionId | ProducteurConnectionCreated_at | ProducteurConnectionUpdated_at | ProducteurConnectionName | ProducteurConnectionClient | ProducteurConnectionLieu | ProducteurConnectionContent | ProducteurConnectionPublished_at | createProducteurPayload | updateProducteurPayload | deleteProducteurPayload | ProductsCategorie | ProductsCategorieConnection | ProductsCategorieAggregator | ProductsCategorieGroupBy | ProductsCategorieConnectionId | ProductsCategorieConnectionCreated_at | ProductsCategorieConnectionUpdated_at | ProductsCategorieConnectionName | ProductsCategorieConnectionSlug | ProductsCategorieConnectionPublished_at | createProductsCategoriePayload | updateProductsCategoriePayload | deleteProductsCategoriePayload | Produit | ProduitConnection | ProduitAggregator | ProduitAggregatorSum | ProduitAggregatorAvg | ProduitAggregatorMin | ProduitAggregatorMax | ProduitGroupBy | ProduitConnectionId | ProduitConnectionCreated_at | ProduitConnectionUpdated_at | ProduitConnectionName | ProduitConnectionPoids | ProduitConnectionPrix | ProduitConnectionProducteurs | ProduitConnectionQuantite | ProduitConnectionStocks | ProduitConnectionImage | ProduitConnectionProducts_categorie | ProduitConnectionPublished_at | createProduitPayload | updateProduitPayload | deleteProduitPayload | I18NLocale | UploadFile | UploadFileConnection | UploadFileAggregator | UploadFileAggregatorSum | UploadFileAggregatorAvg | UploadFileAggregatorMin | UploadFileAggregatorMax | UploadFileGroupBy | UploadFileConnectionId | UploadFileConnectionCreated_at | UploadFileConnectionUpdated_at | UploadFileConnectionName | UploadFileConnectionAlternativeText | UploadFileConnectionCaption | UploadFileConnectionWidth | UploadFileConnectionHeight | UploadFileConnectionFormats | UploadFileConnectionHash | UploadFileConnectionExt | UploadFileConnectionMime | UploadFileConnectionSize | UploadFileConnectionUrl | UploadFileConnectionPreviewUrl | UploadFileConnectionProvider | UploadFileConnectionProvider_metadata | deleteFilePayload | UsersPermissionsPermission | UsersPermissionsRole | UsersPermissionsRoleConnection | UsersPermissionsRoleAggregator | UsersPermissionsRoleGroupBy | UsersPermissionsRoleConnectionId | UsersPermissionsRoleConnectionName | UsersPermissionsRoleConnectionDescription | UsersPermissionsRoleConnectionType | createRolePayload | updateRolePayload | deleteRolePayload | UsersPermissionsUser | UsersPermissionsUserConnection | UsersPermissionsUserAggregator | UsersPermissionsUserGroupBy | UsersPermissionsUserConnectionId | UsersPermissionsUserConnectionCreated_at | UsersPermissionsUserConnectionUpdated_at | UsersPermissionsUserConnectionUsername | UsersPermissionsUserConnectionEmail | UsersPermissionsUserConnectionProvider | UsersPermissionsUserConnectionConfirmed | UsersPermissionsUserConnectionBlocked | UsersPermissionsUserConnectionRole | createUserPayload | updateUserPayload | deleteUserPayload

input InputID {
  id: ID!
}

enum PublicationState {
  LIVE
  PREVIEW
}

type AdminUser {
  id: ID!
  username: String
  firstname: String!
  lastname: String!
}

type Query {
  blog(id: ID!, publicationState: PublicationState): Blog
  blogs(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Blog]
  blogsConnection(sort: String, limit: Int, start: Int, where: JSON): BlogConnection
  blogcategory(id: ID!, publicationState: PublicationState): Blogcategory
  blogcategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Blogcategory]
  blogcategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): BlogcategoryConnection
  producteur(id: ID!, publicationState: PublicationState): Producteur
  producteurs(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Producteur]
  producteursConnection(sort: String, limit: Int, start: Int, where: JSON): ProducteurConnection
  productsCategorie(id: ID!, publicationState: PublicationState): ProductsCategorie
  productsCategories(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [ProductsCategorie]
  productsCategoriesConnection(sort: String, limit: Int, start: Int, where: JSON): ProductsCategorieConnection
  produit(id: ID!, publicationState: PublicationState): Produit
  produits(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [Produit]
  produitsConnection(sort: String, limit: Int, start: Int, where: JSON): ProduitConnection
  files(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UploadFile]
  filesConnection(sort: String, limit: Int, start: Int, where: JSON): UploadFileConnection
  role(id: ID!, publicationState: PublicationState): UsersPermissionsRole

  """
  Retrieve all the existing roles. You can't apply filters on this query.
  """
  roles(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsRole]
  rolesConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsRoleConnection
  user(id: ID!, publicationState: PublicationState): UsersPermissionsUser
  users(sort: String, limit: Int, start: Int, where: JSON, publicationState: PublicationState): [UsersPermissionsUser]
  usersConnection(sort: String, limit: Int, start: Int, where: JSON): UsersPermissionsUserConnection
  me: UsersPermissionsMe
}

type Mutation {
  createBlog(input: createBlogInput): createBlogPayload
  updateBlog(input: updateBlogInput): updateBlogPayload
  deleteBlog(input: deleteBlogInput): deleteBlogPayload
  createBlogcategory(input: createBlogcategoryInput): createBlogcategoryPayload
  updateBlogcategory(input: updateBlogcategoryInput): updateBlogcategoryPayload
  deleteBlogcategory(input: deleteBlogcategoryInput): deleteBlogcategoryPayload
  createProducteur(input: createProducteurInput): createProducteurPayload
  updateProducteur(input: updateProducteurInput): updateProducteurPayload
  deleteProducteur(input: deleteProducteurInput): deleteProducteurPayload
  createProductsCategorie(input: createProductsCategorieInput): createProductsCategoriePayload
  updateProductsCategorie(input: updateProductsCategorieInput): updateProductsCategoriePayload
  deleteProductsCategorie(input: deleteProductsCategorieInput): deleteProductsCategoriePayload
  createProduit(input: createProduitInput): createProduitPayload
  updateProduit(input: updateProduitInput): updateProduitPayload
  deleteProduit(input: deleteProduitInput): deleteProduitPayload

  """Delete one file"""
  deleteFile(input: deleteFileInput): deleteFilePayload

  """Create a new role"""
  createRole(input: createRoleInput): createRolePayload

  """Update an existing role"""
  updateRole(input: updateRoleInput): updateRolePayload

  """Delete an existing role"""
  deleteRole(input: deleteRoleInput): deleteRolePayload

  """Create a new user"""
  createUser(input: createUserInput): createUserPayload

  """Update an existing user"""
  updateUser(input: updateUserInput): updateUserPayload

  """Delete an existing user"""
  deleteUser(input: deleteUserInput): deleteUserPayload
  upload(refId: ID, ref: String, field: String, source: String, info: FileInfoInput, file: Upload!): UploadFile!
  multipleUpload(refId: ID, ref: String, field: String, source: String, files: [Upload]!): [UploadFile]!
  updateFileInfo(id: ID!, info: FileInfoInput!): UploadFile!
  login(input: UsersPermissionsLoginInput!): UsersPermissionsLoginPayload!
  register(input: UsersPermissionsRegisterInput!): UsersPermissionsLoginPayload!
  forgotPassword(email: String!): UserPermissionsPasswordPayload
  resetPassword(password: String!, passwordConfirmation: String!, code: String!): UsersPermissionsLoginPayload
  emailConfirmation(confirmation: String!): UsersPermissionsLoginPayload
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

"""A time string with format: HH:mm:ss.SSS"""
scalar Time

"""
A date string, such as 2007-12-03, compliant with the `full-date` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar Date

"""The `Long` scalar type represents 52-bit integers"""
scalar Long

"""The `Upload` scalar type represents a file upload."""
scalar Upload
